package arith.lang;

import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import arith.lang.Compiler.*;
import java_cup.runtime.*;

class Parser;

parser code {:
  public Parser(Reader input) {
    super(new Lexer(input));
  }

  public Term f(int n) { 
    if(n == 0) { return new TmZero(); }
    else { return new TmSucc(f(n-1)); }
  }

  List<Term> commands = new ArrayList<Term>();
:}


/* Terminals (tokens returned by the sanner). */
terminal Integer INTV;
terminal TRUE, FALSE, IF, THEN, ELSE, SUCC, PRED, ISZERO;
terminal SEMI, LPAREN, RPAREN;

/* Non terminal */
non terminal command, term, appterm, aterm;


/* The grammar rules 
toplevel ::= command:c SEMI toplevel:cmds {: let cmd = $1 in
                                        let cmds = $3 in
                                        cmd::cmds :}
                                        ;
                                        */
command ::= term:t  {: RESULT = t; /*(let t = $1 in Eval(tmInfo t,t))*/ :}
;

term ::= appterm:t {: RESULT = t; :}
  | IF term:t1 THEN term:t2 ELSE term:t3 
     {: RESULT = new TmIf((Term)t1, (Term)t2, (Term)t3); :}
;

appterm ::=
    aterm:t
      {: RESULT = t; :}
  | SUCC aterm:t
      {: RESULT = new TmSucc((Term)t); :}
  | PRED aterm:t
      {: RESULT = new TmPred((Term)t); :}
  | ISZERO aterm:t
      {: RESULT = new TmIsZero((Term)t); :}
;

/* Atomic terms are ones that never require extra parentheses */
aterm ::=
    LPAREN term:t RPAREN  
      {: RESULT = t; :} 
  | TRUE
      {: RESULT = new TmTrue(); :} 
  | FALSE
      {: RESULT = new TmFalse(); :}
  | INTV:i
      {: RESULT = f(i);
         /* let rec f n = match n with
              0 -> TmZero($1.i)
            | n -> TmSucc($1.i, f (n-1))
          in f $1.v */ :}
;

