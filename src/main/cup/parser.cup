package arith.lang;

import java.util.LinkedList;
import java.io.Reader;
import arith.lang.Compiler.*;
import java_cup.runtime.*;

class Parser;

parser code {:
  public Parser(Reader input) {
    super(new Lexer(input));
  }

  public Term f(int n) { 
    if(n == 0) { return new TmZero(); }
    else { return new TmSucc(f(n-1)); }
  }

  LinkedList<Term> commands = new LinkedList<Term>();
:}


/* Terminals (tokens returned by the sanner). */
terminal Integer INTV;
terminal TRUE, FALSE, IF, THEN, ELSE, SUCC, PRED, ISZERO;
terminal SEMI, LPAREN, RPAREN;

/* Non terminal */
non terminal toplevel, command, term, appterm, aterm;


/* The grammar rules */
toplevel ::= command:c SEMI toplevel:cmds {: System.out.println(c);
                                    commands.addFirst((Term)c);
                                    RESULT = new TmTopLevel(commands); :}
  | error:e {: parser.report_error("Syntax error, skipped nonsense", e); :}
;

command ::= 
  term:t {: System.out.println(t); RESULT = t; :}
  | error:e {: parser.report_error("Syntax error, skipped nonsense", e); :}
;

term ::= appterm:t {: RESULT = t; :}
  | IF term:t1 THEN term:t2 ELSE term:t3 
     {: RESULT = new TmIf((Term)t1, (Term)t2, (Term)t3); :}
;

appterm ::=
    aterm:t
      {: RESULT = t; :}
  | SUCC aterm:t
      {: RESULT = new TmSucc((Term)t); :}
  | PRED aterm:t
      {: RESULT = new TmPred((Term)t); :}
  | ISZERO aterm:t
      {: RESULT = new TmIsZero((Term)t); :}
;

/* Atomic terms are ones that never require extra parentheses */
aterm ::=
    LPAREN term:t RPAREN  
      {: RESULT = t; :} 
  | TRUE
      {: RESULT = new TmTrue(); :} 
  | FALSE
      {: RESULT = new TmFalse(); :}
  | INTV:i
      {: 
         Term t = f(i);
         RESULT = t; 
      :}
;

